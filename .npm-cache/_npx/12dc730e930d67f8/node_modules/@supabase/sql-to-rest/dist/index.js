var O=class extends Error{constructor(r,o){super(ue(r));this.hint=o}name="ParsingError"},R=class extends Error{name="UnimplementedError"},n=class extends Error{constructor(r,o){super(r);this.hint=o}name="UnsupportedError"},x=class extends Error{constructor(r,o){super(r);this.renderer=o}name="RenderError"};function ue(e){if(typeof e!="string")throw new TypeError("Expected a string");return e.length===0?e:e[0].toUpperCase()+e.slice(1)}function M(e){switch(e){case'syntax error at or near "from"':return"Did you leave a trailing comma in the select target list?";case'syntax error at or near "where"':return"Do you have an incomplete join in the FROM clause?";default:}}import{PgParser as Ee,unwrapParseResult as xe}from"@supabase/pg-parser";function v(e,t){if(!e.name||e.name.length===0)throw new n("JSON operator must have a name");if(e.name.length>1)throw new n("Only one operator name supported per expression");let[r]=e.name;if(!("String"in r))throw new n("JSON operator name must be a string");let o=r.String.sval;if(!o)throw new n("JSON operator name cannot be empty");if(!["->","->>"].includes(o))throw new n("Invalid JSON operator");let s,a,i;if(!e.lexpr)throw new n("JSON path must have a left expression");if("A_Const"in e.lexpr){if("fval"in e.lexpr.A_Const)throw new n("Invalid JSON path");a=S(e.lexpr.A_Const)}else if("A_Expr"in e.lexpr){let{column:l}=v(e.lexpr.A_Expr,t);a=l}else if("ColumnRef"in e.lexpr){if(!e.lexpr.ColumnRef.fields)throw new n("JSON path must have a column reference");a=w(e.lexpr.ColumnRef.fields,t)}else throw new n("Invalid JSON path");if(!e.rexpr||!e.rexpr)throw new n("JSON path must have a right expression");if("A_Const"in e.rexpr){if("fval"in e.rexpr.A_Const)throw new n("Invalid JSON path");i=S(e.rexpr.A_Const)}else if("TypeCast"in e.rexpr){if(!e.rexpr.TypeCast.typeName?.names)throw new n("Type cast must have a name");if(s=W(e.rexpr.TypeCast.typeName.names.map(l=>{if(!("String"in l))throw new n("Type cast name must be a string");return l.String})),!e.rexpr.TypeCast.arg)throw new n("Type cast must have an argument");if("A_Const"in e.rexpr.TypeCast.arg)if("sval"in e.rexpr.TypeCast.arg.A_Const){if(!e.rexpr.TypeCast.arg.A_Const.sval?.sval)throw new n("Type cast argument cannot be empty");i=e.rexpr.TypeCast.arg.A_Const.sval.sval}else throw new n("Invalid JSON path");else throw new n("Invalid JSON path")}else throw new n("Invalid JSON path");return{type:"column-target",column:`${a}${o}${i}`,cast:s}}function w(e,t,r="dot"){let o=e.map(l=>{if("String"in l)return l.String.sval;if("A_Star"in l)return"*";{let[u]=Object.keys(l);throw new n(`Unsupported internal type '${u}' for data type names`)}}),[s]=o.slice(-2,-1),[a]=o.slice(-1),i=t.joined.find(l=>(l.alias??l.relation)===s);if(!s||s===t.primary.reference){if(!a)throw new n("Column name cannot be empty");return a}else if(i){let l=i.flatten?i.relation:s;if(r==="dot")return[l,a].join(".");if(r==="parenthesis")return`${l}(${a})`;throw new Error(`Unknown render syntax '${r}'`)}else{let l=[s,a].join(".");throw new n(`Found foreign column '${l}' without a join to that relation`,"Did you forget to join that relation or alias it to something else?")}}function W(e){let[t,...r]=e;if(!t)throw new n("Data type must have a name");if(t.sval==="pg_catalog"&&r.length===1){let[o]=r;if(!o)throw new n("Data type must have a name");switch(o.sval){case"int2":return"smallint";case"int4":return"int";case"int8":return"bigint";case"float8":return"float";default:return o.sval}}else{if(r.length>0)throw new n("Casts can only reference data types by their unqualified name (not schema-qualified)");return t.sval}}function S(e){if("sval"in e){if(e.sval?.sval===void 0)throw new n("Constant value cannot be empty");return e.sval.sval}else if("ival"in e){if(e.ival===void 0)throw new n("Constant value cannot be undefined");return e.ival.ival??0}else if("fval"in e){if(e.fval?.fval===void 0)throw new n("Constant value cannot be undefined");return parseFloat(e.fval.fval)}else throw new n("Constant values must be a string, integer, or float")}function X(e){return e.flatMap(t=>{let{type:r}=t;if(r==="column-target"||r==="aggregate-target")return t;if(r==="embedded-target")return[t,...X(t.targets)];throw new n(`Unknown target type '${r}'`)})}function G(e,t){let{type:r}=e;if(r==="column")return t(e);if(r==="logical")return e.values.some(o=>G(o,t));throw new n(`Unknown filter type '${r}'`)}function j(e,t,r){return e.every(o=>{let{type:s}=o;if(s==="column-target"||s==="aggregate-target")return t(o,r);if(s==="embedded-target")return j(o.targets,t,o);throw new n(`Unknown target type '${s}'`)})}function C(e,t,r){return e.some(o=>{let{type:s}=o;if(s==="column-target"||s==="aggregate-target")return t(o,r);if(s==="embedded-target")return C(o.targets,t,o);throw new n(`Unknown target type '${s}'`)})}function Q(e,t,r){let o=e.map(s=>{if(!s.fields)throw new n("Group by clause must contain at least one column");return w(s.fields,r)??[]});if(!o.every(s=>C(t,(a,i)=>"column"in a?(i?[i.alias&&!i.flatten?i.alias:i.relation,a.column]:[a.column]).join(".")===s:!1)))throw new n("Every group by column must also exist as a select target");if(C(t,s=>s.type==="aggregate-target")&&!j(t,(s,a)=>{if(s.type==="aggregate-target")return!0;let l=(a?[a.alias&&!a.flatten?a.alias:a.relation,s.column]:[s.column]).join(".");return o.some(u=>l===u)}))throw new n("Every non-aggregate select target must also exist in a group by clause");if(o.length>0&&!C(t,s=>s.type==="aggregate-target"))throw new n("There must be at least one aggregate function in the select target list when using group by")}function k(e,t){if("A_Expr"in e){let r;if(!e.A_Expr.name||e.A_Expr.name.length>1)throw new n("Only one operator name supported per expression");let o=e.A_Expr.kind;if(!o)throw new n("WHERE clause must have an operator kind");let[s]=e.A_Expr.name;if(!s)throw new n("WHERE clause must have an operator name");if(!("String"in s))throw new n("WHERE clause operator name must be a string");if(!s.String.sval)throw new n("WHERE clause operator name cannot be empty");let a=s.String.sval.toLowerCase(),i=fe(o,a);if(!e.A_Expr.lexpr)throw new n("Left side of WHERE clause must be a column or expression");if("A_Expr"in e.A_Expr.lexpr)try{r=v(e.A_Expr.lexpr.A_Expr,t).column}catch{throw new n("Left side of WHERE clause must be a column")}else if("ColumnRef"in e.A_Expr.lexpr){let{fields:l}=e.A_Expr.lexpr.ColumnRef;if(!l||l.length===0)throw new n("Left side of WHERE clause must reference a column");r=w(l,t)}else{if("TypeCast"in e.A_Expr.lexpr)throw new n("Casting is not supported in the WHERE clause");if("FuncCall"in e.A_Expr.lexpr){if(!e.A_Expr.lexpr.FuncCall.funcname)throw new n("Left side of WHERE clause must reference a column");let l=w(e.A_Expr.lexpr.FuncCall.funcname,t);if(i==="fts")if(l==="to_tsvector"){if(!e.A_Expr.lexpr.FuncCall.args||e.A_Expr.lexpr.FuncCall.args.length!==1)throw new n(`${l} requires 1 column argument`);let[u]=e.A_Expr.lexpr.FuncCall.args;if(!u)throw new n(`${l} requires a column argument`);if("A_Expr"in u)try{r=v(u.A_Expr,t).column}catch{throw new n(`${l} requires a column argument`)}else if("ColumnRef"in u){let{fields:m}=u.ColumnRef;if(!m)throw new n(`${l} requires a column argument`);r=w(m,t)}else throw"TypeCast"in u?new n("Casting is not supported in the WHERE clause"):new n(`${l} requires a column argument`)}else throw new n("Only 'to_tsvector' function allowed on left side of text search operator");else throw new n("Left side of WHERE clause must be a column")}else throw new n("Left side of WHERE clause must be a column")}if(i==="eq"||i==="neq"||i==="gt"||i==="gte"||i==="lt"||i==="lte"){if(!e.A_Expr.rexpr)throw new n(`Right side of WHERE clause '${a}' expression must be present`);if(!("A_Const"in e.A_Expr.rexpr))throw new n(`Right side of WHERE clause '${a}' expression must be a constant`,"Did you forget to wrap your value in single quotes?");let l=S(e.A_Expr.rexpr.A_Const);return{type:"column",column:r,operator:i,negate:!1,value:l}}else if(i==="between"||i==="between symmetric"||i==="not between"||i==="not between symmetric"){if(!e.A_Expr.rexpr)throw new n(`Right side of WHERE clause '${a}' expression must be present`);if(!("List"in e.A_Expr.rexpr)||e.A_Expr.rexpr.List.items?.length!==2)throw new n(`Right side of WHERE clause '${a}' expression must contain two constants`);let[l,u]=e.A_Expr.rexpr.List.items.map(g=>{if(!("A_Const"in g))throw new n(`Right side of WHERE clause '${a}' expression must contain two constants`);return S(g.A_Const)});if(i.includes("symmetric")){if(typeof l!="number"||typeof u!="number")throw new n("BETWEEN SYMMETRIC is only supported with number values");if(l>u){let g=u;u=l,l=g}}if(!l)throw new n(`Left side of WHERE clause '${a}' expression must be a constant`);let m={type:"column",column:r,operator:"gte",negate:!1,value:l};if(!u)throw new n(`Right side of WHERE clause '${a}' expression must be a constant`);let f={type:"column",column:r,operator:"lte",negate:!1,value:u};return{type:"logical",operator:"and",negate:i.includes("not"),values:[m,f]}}else if(i==="like"||i==="ilike"||i==="match"||i==="imatch"){if(!e.A_Expr.rexpr)throw new n(`Right side of WHERE clause '${a}' expression must be present`);if(!("A_Const"in e.A_Expr.rexpr)||!("sval"in e.A_Expr.rexpr.A_Const)||!e.A_Expr.rexpr.A_Const.sval?.sval)throw new n(`Right side of WHERE clause '${i}' expression must be a string constant`);let l=e.A_Expr.rexpr.A_Const.sval.sval;return{type:"column",column:r,operator:i,negate:!1,value:l}}else if(i==="in"){if(!e.A_Expr.rexpr)throw new n(`Right side of WHERE clause '${a}' expression must be present`);if(!("List"in e.A_Expr.rexpr)||!e.A_Expr.rexpr.List.items?.every(u=>"A_Const"in u))throw new n(`Right side of WHERE clause '${i}' expression must be a list of constants`);let l=e.A_Expr.rexpr.List.items.map(u=>S(u.A_Const));return{type:"column",column:r,operator:i,negate:!1,value:l}}else if(i==="fts"){let l=["to_tsquery","plainto_tsquery","phraseto_tsquery","websearch_to_tsquery"];if(!e.A_Expr.rexpr)throw new n(`Right side of WHERE clause '${a}' expression must be present`);if(!("FuncCall"in e.A_Expr.rexpr)||!e.A_Expr.rexpr.FuncCall.funcname)throw new n(`Right side of WHERE clause '${a}' expression must be one of these functions: ${l.join(", ")}`);let u=w(e.A_Expr.rexpr.FuncCall.funcname,t);if(!l.includes(u))throw new n(`Right side of WHERE clause '${a}' expression must be one of these functions: ${l.join(", ")}`);if(!e.A_Expr.rexpr.FuncCall.args||e.A_Expr.rexpr.FuncCall.args.length===0||e.A_Expr.rexpr.FuncCall.args.length>2)throw new n(`${u} requires 1 or 2 arguments`);let m=e.A_Expr.rexpr.FuncCall.args.map(_=>{if(!("A_Const"in _)||!_.A_Const.sval?.sval)throw new n(`${u} only accepts text arguments`);return _.A_Const.sval.sval}),[f]=m.slice(-2,-1),[g]=m.slice(-1);if(!g)throw new n(`${u} requires a query argument`);let A=me(u);return{type:"column",column:r,operator:A,config:f,value:g,negate:!1}}else throw new n(`Unsupported operator '${a}'`)}else if("NullTest"in e){if(!e.NullTest.arg||!("ColumnRef"in e.NullTest.arg))throw new n("NullTest expression must have an argument of type ColumnRef");let{fields:r}=e.NullTest.arg.ColumnRef;if(!r)throw new n("NullTest expression must reference a column");let o=w(r,t),s=e.NullTest.nulltesttype==="IS_NOT_NULL";return{type:"column",column:o,operator:"is",negate:s,value:null}}else if("BoolExpr"in e){let r;if(e.BoolExpr.boolop==="AND_EXPR")r="and";else if(e.BoolExpr.boolop==="OR_EXPR")r="or";else if(e.BoolExpr.boolop==="NOT_EXPR")r="not";else throw new n(`Unknown boolop '${e.BoolExpr.boolop}'`);if(!e.BoolExpr.args)throw new n("BoolExpr must have arguments");let o=e.BoolExpr.args.map(s=>k(s,t));if(r==="not"){if(o.length>1)throw new n(`NOT expressions must have only 1 child, but received ${o.length} children`);let[s]=o;if(!s)throw new n("NOT expression must have a child filter");return s.negate=!0,s}return{type:"logical",operator:r,negate:!1,values:o}}else throw new n("The WHERE clause must contain an expression")}function fe(e,t){switch(e){case"AEXPR_OP":switch(t){case"=":return"eq";case"<>":return"neq";case">":return"gt";case">=":return"gte";case"<":return"lt";case"<=":return"lte";case"~":return"match";case"~*":return"imatch";case"@@":return"fts";default:throw new n(`Unsupported operator '${t}'`)}case"AEXPR_BETWEEN":case"AEXPR_BETWEEN_SYM":case"AEXPR_NOT_BETWEEN":case"AEXPR_NOT_BETWEEN_SYM":switch(t){case"between":return"between";case"between symmetric":return"between symmetric";case"not between":return"not between";case"not between symmetric":return"not between symmetric";default:throw new n(`Unsupported operator '${t}'`)}case"AEXPR_LIKE":switch(t){case"~~":return"like";default:throw new n(`Unsupported operator '${t}'`)}case"AEXPR_ILIKE":switch(t){case"~~*":return"ilike";default:throw new n(`Unsupported operator '${t}'`)}case"AEXPR_IN":switch(t){case"=":return"in";default:throw new n(`Unsupported operator '${t}'`)}}}function me(e){switch(e){case"to_tsquery":return"fts";case"plainto_tsquery":return"plfts";case"phraseto_tsquery":return"phfts";case"websearch_to_tsquery":return"wfts";default:throw new n(`Function '${e}' not supported for full-text search`)}}function K(e){let t,r;if(e.limitCount){if(!("A_Const"in e.limitCount))throw new n("Limit count must be an A_Const");if(!("ival"in e.limitCount.A_Const))throw new n("Limit count must be an integer");if(!e.limitCount.A_Const.ival)throw new n("Limit count must have an integer value");t=e.limitCount.A_Const.ival.ival}if(e.limitOffset){if(!("A_Const"in e.limitOffset))throw new n("Limit offset must be an A_Const");if(!("ival"in e.limitOffset.A_Const))throw new n("Limit offset must be an integer");if(!e.limitOffset.A_Const.ival)throw new n("Limit offset must have an integer value");r=e.limitOffset.A_Const.ival.ival}if(!(t===void 0&&r===void 0))return{count:t,offset:r}}function z(e,t){return e.map(r=>{let o;if(!r.node)throw new n("ORDER BY clause must reference a column");if("A_Expr"in r.node)try{o=v(r.node.A_Expr,t).column}catch{throw new n("ORDER BY clause must reference a column")}else if("ColumnRef"in r.node){let{fields:i}=r.node.ColumnRef;if(!i)throw new n("ORDER BY clause must reference a column");o=w(i,t,"parenthesis")}else throw"TypeCast"in r.node?new n("Casting is not supported in the ORDER BY clause"):new n("ORDER BY clause must reference a column");if(!r.sortby_dir)throw new n("ORDER BY clause must specify a direction");let s=pe(r.sortby_dir);if(!r.sortby_nulls)throw new n("ORDER BY clause must specify nulls handling");let a=ce(r.sortby_nulls);return{column:o,direction:s,nulls:a}})}function pe(e){switch(e){case"SORTBY_ASC":return"asc";case"SORTBY_DESC":return"desc";case"SORTBY_DEFAULT":return;default:throw new n(`Unknown sort by direction '${e}'`)}}function ce(e){switch(e){case"SORTBY_NULLS_FIRST":return"first";case"SORTBY_NULLS_LAST":return"last";case"SORTBY_NULLS_DEFAULT":return;default:throw new n(`Unknown sort by nulls '${e}'`)}}var B=["avg","count","max","min","sum"];function Z(e){if(!e)throw new n("Expected a statement, but received an empty one");if(!e.fromClause)throw new n("The query must have a from clause");if(!e.targetList)throw new n("The query must have a target list");if(e.fromClause.length>1)throw new n("Only one FROM source is supported");if(e.withClause)throw new n("CTEs are not supported");if(e.distinctClause)throw new n("SELECT DISTINCT is not supported");if(e.havingClause)throw new n("The HAVING clause is not supported");let[t]=e.fromClause;if(!t)throw new n("The FROM clause must have a relation");let r=ee(t),o=r.primary.name,s=e.targetList.map(g=>{if(!("ResTarget"in g))throw new n("Target list must contain ResTarget nodes");return g.ResTarget}),a=ge(s,r),i=e.groupClause?.map(g=>{if(!("ColumnRef"in g))throw new n("Group by clause must contain column references");return g.ColumnRef})??[];Q(i,a,r);let l=e.whereClause?k(e.whereClause,r):void 0,u=e.sortClause?.map(g=>{if(!("SortBy"in g))throw new n("Sort clause must contain SortBy nodes");return g.SortBy})??[],m=z(u,r),f=K(e);return{type:"select",from:o,targets:a,filter:l,sorts:m,limit:f}}function ee(e){if("RangeVar"in e){if(!e.RangeVar.relname)throw new n("The FROM clause must have a relation name");return{primary:{name:e.RangeVar.relname,alias:e.RangeVar.alias?.aliasname,get reference(){return this.alias??this.name}},joined:[]}}else if("JoinExpr"in e){if(!e.JoinExpr.jointype)throw new n("Join expression must have a join type");if(!e.JoinExpr.larg||!e.JoinExpr.rarg)throw new n("Join expression must have both left and right relations");let t=de(e.JoinExpr.jointype),{primary:r,joined:o}=ee(e.JoinExpr.larg);if(!("RangeVar"in e.JoinExpr.rarg))throw new n("Join expression must have a right relation of type RangeVar");let a=e.JoinExpr.rarg.RangeVar.alias?.aliasname??e.JoinExpr.rarg.RangeVar.relname,i=[r.reference,...o.map(T=>T.alias??T.relation),a];if(!e.JoinExpr.quals||!("A_Expr"in e.JoinExpr.quals))throw new n("Join qualifier must be an expression comparing columns");let l,u,m=e.JoinExpr.quals.A_Expr;if(!m.lexpr||!("ColumnRef"in m.lexpr))throw new n("Left side of join qualifier must be a column");if(!m.lexpr.ColumnRef.fields||!m.lexpr.ColumnRef.fields.every(T=>"String"in T))throw new n("Left side column of join qualifier must contain String fields");let f=m.lexpr.ColumnRef.fields.map(T=>T.String.sval),[g]=f.slice(-2,-1),[A]=f.slice(-1);if(!A)throw new n("Left side of join qualifier must have a column name");if(!g)l=r.reference;else if(i.includes(g))l=g;else if(g===a)l=a;else throw new n(`Left side of join qualifier references a different relation (${g}) than the join (${i.join(", ")})`);if(!m.rexpr)throw new n("Join qualifier must have a right side expression");if(!("ColumnRef"in m.rexpr))throw new n("Right side of join qualifier must be a column");if(!m.rexpr.ColumnRef.fields?.every(T=>"String"in T))throw new n("Right side column of join qualifier must contain String fields");let _=m.rexpr.ColumnRef.fields.map(T=>T.String.sval),[N]=_.slice(-2,-1),[I]=_.slice(-1);if(!I)throw new n("Right side of join qualifier must have a column name");if(!N)u=r.reference;else if(i.includes(N))u=N;else if(N===a)u=a;else throw new n(`Right side of join qualifier references a different relation (${N}) than the join (${i.join(", ")})`);if(u===l)throw new n("Join qualifier cannot compare columns from same relation");if(u!==a&&l!==a)throw new n("Join qualifier must reference a column from the joined table");if(!m.name)throw new n("Join qualifier must have an operator");let[U]=m.name;if(!U||!("String"in U))throw new n("Join qualifier operator must be a string");if(U.String.sval!=="=")throw new n("Join qualifier operator must be '='");let H,P;if(u===a?(H={relation:l,column:A},P={relation:u,column:I}):(P={relation:l,column:A},H={relation:u,column:I}),!e.JoinExpr.rarg.RangeVar.relname)throw new n("Join expression must have a right relation name");let le={type:"embedded-target",relation:e.JoinExpr.rarg.RangeVar.relname,alias:e.JoinExpr.rarg.RangeVar.alias?.aliasname,joinType:t,targets:[],flatten:!0,joinedColumns:{left:H,right:P}};return{primary:r,joined:[...o,le]}}else{let[t]=Object.keys(e);throw new n(`Unsupported FROM clause type '${t}'`)}}function ge(e,t){let o=e.map(a=>{if(!a.val)throw new n("Target list item must have a value");let i=D(a.val,t);return i.alias=a.name,i}).filter(a=>{if(a.type==="aggregate-target"&&!("column"in a))return!0;let i=a.column.split("."),[l]=i.slice(-2,-1),[u]=i.slice(-1);if(!l)return!0;if(!u)throw new n("Column name cannot be empty in target list");if(l){let m=t.joined.find(f=>(f.alias&&!f.flatten?f.alias:f.relation)===l);if(!m)throw new n(`Found foreign column '${a.column}' in target list without a join to that relation`,"Did you forget to join that relation or alias it to something else?");return a.column=u,m.targets.push(a),!1}return!0}),s=t.joined.reduce((a,i)=>{if(i.joinedColumns.left.relation===t.primary.reference)return[...a,i];let l=t.joined.find(u=>(u.alias??u.relation)===i.joinedColumns.left.relation);if(!l)throw new n(`Something went wrong, could not find parent embedded target for nested embedded target '${i.relation}'`);return l.targets.push(i),a},[]);return[...o,...s]}function D(e,t){if("TypeCast"in e)return he(e.TypeCast,t);if("ColumnRef"in e)return we(e.ColumnRef,t);if("A_Expr"in e)return ye(e.A_Expr,t);if("FuncCall"in e)return Te(e.FuncCall,t);throw new n("Only columns, JSON fields, and aggregates are supported as query targets")}function de(e){switch(e){case"JOIN_INNER":return"inner";case"JOIN_LEFT":return"left";default:throw new n(`Unsupported join type '${e}'`)}}function he(e,t){if(!e.typeName?.names)throw new n("Type cast must have a type name");let r=e.typeName.names.map(i=>{if(!("String"in i))throw new n("Type cast name must be a string");return i.String}),o=W(r);if(!e.arg)throw new n("Type cast must have an argument");if("A_Const"in e.arg)throw new n("Only columns, JSON fields, and aggregates are supported as query targets");let s=D(e.arg,t),{type:a}=s;if(a==="aggregate-target")return{...s,outputCast:o};if(a==="column-target")return{...s,cast:o};throw new n(`Cannot process target with type '${a}'`)}function we(e,t){if(!e.fields)throw new n("Column reference must have fields");return{type:"column-target",column:w(e.fields,t)}}function ye(e,t){try{return v(e,t)}catch(r){let o=r instanceof Error&&r.message==="Invalid JSON path"?"Did you forget to quote a JSON path?":void 0;throw new n("Expressions not supported as targets",o)}}function Te(e,t){if(!e.funcname)throw new n("Aggregate function must have a name");let r=w(e.funcname,t);if(!B.includes(r))throw new n(`Only the following aggregate functions are supported: ${JSON.stringify(B)}`);if(r==="count"&&!e.args&&e.agg_star)return{type:"aggregate-target",functionName:r};if(!e.args)throw new n(`Aggregate function '${r}' requires a column argument`);if(e.args&&e.args.length>1)throw new n("Aggregate functions only accept one argument");let[o]=e.args;if(!o)throw new n(`Aggregate function '${r}' requires a column argument`);let s=D(o,t);if(s.type==="aggregate-target")throw new n("Aggregate functions cannot contain another function");let{cast:a,...i}=s;return{...i,type:"aggregate-target",functionName:r,inputCast:a}}var ve=new Ee;async function bt(e){try{let t=await xe(ve.parse(e));if(!t.stmts||t.stmts.length===0)throw new n("Expected a statement, but received none");if(t.stmts.length>1)throw new n("Expected a single statement, but received multiple");let[r]=t.stmts.map(o=>{if(!o)throw new n("Expected a statement, but received an empty one");return Re(o)});return r}catch(t){if(t instanceof Error&&"cursorPosition"in t){let r=M(t.message),o=new O(t.message,r);throw Object.assign(o,t),o}else throw t}}function Re({stmt:e}){if(!e)throw new n("Expected a statement, but received an empty one");if("SelectStmt"in e)return Z(e.SelectStmt);if("InsertStmt"in e)throw new R("Insert statements are not yet implemented by the translator");if("UpdateStmt"in e)throw new R("Update statements are not yet implemented by the translator");if("DeleteStmt"in e)throw new R("Delete statements are not yet implemented by the translator");if("ExplainStmt"in e)throw new R("Explain statements are not yet implemented by the translator");{let[t]=Object.keys(e);if(!t)throw new n("Expected a statement, but received an empty one");let r=t.replace(/Stmt$/,"");throw new n(`${r} statements are not supported`)}}var _e=function(){function e(t,r){for(var o=0;o<r.length;o++){var s=r[o];s.enumerable=s.enumerable||!1,s.configurable=!0,"value"in s&&(s.writable=!0),Object.defineProperty(t,s.key,s)}}return function(t,r,o){return r&&e(t.prototype,r),o&&e(t,o),t}}(),Se=Ce(["",""],["",""]);function Ce(e,t){return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}function be(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var $e=function(){function e(){for(var t=this,r=arguments.length,o=Array(r),s=0;s<r;s++)o[s]=arguments[s];return be(this,e),this.tag=function(a){for(var i=arguments.length,l=Array(i>1?i-1:0),u=1;u<i;u++)l[u-1]=arguments[u];return typeof a=="function"?t.interimTag.bind(t,a):typeof a=="string"?t.transformEndResult(a):(a=a.map(t.transformString.bind(t)),t.transformEndResult(a.reduce(t.processSubstitutions.bind(t,l))))},o.length>0&&Array.isArray(o[0])&&(o=o[0]),this.transformers=o.map(function(a){return typeof a=="function"?a():a}),this.tag}return _e(e,[{key:"interimTag",value:function(r,o){for(var s=arguments.length,a=Array(s>2?s-2:0),i=2;i<s;i++)a[i-2]=arguments[i];return this.tag(Se,r.apply(void 0,[o].concat(a)))}},{key:"processSubstitutions",value:function(r,o,s){var a=this.transformSubstitution(r.shift(),o);return"".concat(o,a,s)}},{key:"transformString",value:function(r){var o=function(a,i){return i.onString?i.onString(a):a};return this.transformers.reduce(o,r)}},{key:"transformSubstitution",value:function(r,o){var s=function(i,l){return l.onSubstitution?l.onSubstitution(i,o):i};return this.transformers.reduce(s,r)}},{key:"transformEndResult",value:function(r){var o=function(a,i){return i.onEndResult?i.onEndResult(a):a};return this.transformers.reduce(o,r)}}]),e}(),p=$e;var Ae=function(){var t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"";return{onEndResult:function(o){if(t==="")return o.trim();if(t=t.toLowerCase(),t==="start"||t==="left")return o.replace(/^\s*/,"");if(t==="end"||t==="right")return o.replace(/\s*$/,"");throw new Error("Side not supported: "+t)}}},c=Ae;function Ne(e){if(Array.isArray(e)){for(var t=0,r=Array(e.length);t<e.length;t++)r[t]=e[t];return r}else return Array.from(e)}var Le=function(){var t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"initial";return{onEndResult:function(o){if(t==="initial"){var s=o.match(/^[^\S\n]*(?=\S)/gm),a=s&&Math.min.apply(Math,Ne(s.map(function(l){return l.length})));if(a){var i=new RegExp("^.{"+a+"}","gm");return o.replace(i,"")}return o}if(t==="all")return o.replace(/^[^\S\n]+/gm,"");throw new Error("Unknown type: "+t)}}},h=Le;var Oe=function(t,r){return{onEndResult:function(s){if(t==null||r==null)throw new Error("replaceResultTransformer requires at least 2 arguments.");return s.replace(t,r)}}},y=Oe;var je=function(t,r){return{onSubstitution:function(s,a){if(t==null||r==null)throw new Error("replaceSubstitutionTransformer requires at least 2 arguments.");return s==null?s:s.toString().replace(t,r)}}},E=je;var Fe={separator:"",conjunction:"",serial:!1},qe=function(){var t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:Fe;return{onSubstitution:function(o,s){if(Array.isArray(o)){var a=o.length,i=t.separator,l=t.conjunction,u=t.serial,m=s.match(/(\n?[^\S\n]+)$/);if(m?o=o.join(i+m[1]):o=o.join(i+" "),l&&a>1){var f=o.lastIndexOf(i);o=o.slice(0,f)+(u?i:"")+" "+l+o.slice(f+1)}}return o}}},d=qe;var Ie=function(t){return{onSubstitution:function(o,s){if(t!=null&&typeof t=="string")typeof o=="string"&&o.includes(t)&&(o=o.split(t));else throw new Error("You need to specify a string character to split by.");return o}}},b=Ie;var te=function(t){return t!=null&&!Number.isNaN(t)&&typeof t!="boolean"},Ue=function(){return{onSubstitution:function(r){return Array.isArray(r)?r.filter(te):te(r)?r:""}}},J=Ue;var ur=new p(d({separator:","}),h,c);var wr=new p(d({separator:",",conjunction:"and"}),h,c);var Sr=new p(d({separator:",",conjunction:"or"}),h,c);var Fr=new p(b(`
`),J,d,h,c);var Gr=new p(b(`
`),d,h,c,E(/&/g,"&amp;"),E(/</g,"&lt;"),E(/>/g,"&gt;"),E(/"/g,"&quot;"),E(/'/g,"&#x27;"),E(/`/g,"&#x60;"));var rn=new p(y(/(?:\n(?:\s*))+/g," "),c);var fn=new p(y(/(?:\n\s*)/g,""),c);var yn=new p(d({separator:","}),y(/(?:\s+)/g," "),c);var Cn=new p(d({separator:",",conjunction:"or"}),y(/(?:\s+)/g," "),c);var Jn=new p(d({separator:",",conjunction:"and"}),y(/(?:\s+)/g," "),c);var kn=new p(d,h,c);var Qn=new p(d,y(/(?:\s+)/g," "),c);var Qe=new p(h,c),F=Qe;var uo=new p(h("all"),c);function $(e,t){let r=t?" ".repeat(t.initialIndent):"",o=t?`
`:"";return e.map(s=>{if(s.type==="column-target"){let{column:a,alias:i,cast:l}=s,u=a;return i&&i!==a&&(u=`${i}:${u}`),l&&(u=`${u}::${l}`),u=`${r}${u}`,u}else if(s.type==="aggregate-target"&&!("column"in s)){let{functionName:a,alias:i,outputCast:l}=s,u=`${a}()`;return i&&(u=`${i}:${u}`),l&&(u=`${u}::${l}`),u=`${r}${u}`,u}else if(s.type==="aggregate-target"){let{column:a,alias:i,functionName:l,inputCast:u,outputCast:m}=s,f=a;return i&&i!==a&&(f=`${i}:${f}`),u&&(f=`${f}::${u}`),f=`${f}.${l}()`,m&&(f=`${f}::${m}`),f=`${r}${f}`,f}else if(s.type==="embedded-target"){let{relation:a,alias:i,joinType:l,targets:u,flatten:m}=s,f=a;return l==="inner"&&(f=`${f}!inner`),i&&i!==a&&!m&&(f=`${i}:${f}`),m&&(f=`...${f}`),u.length>0?f=`${r}${f}(${o}${$(u,t?{...t,initialIndent:t.initialIndent+t.indent}:void 0)}${o}${r})`:f=`${r}${f}()`,f}}).join(","+o)}function V(e,t=!0,r=","){let{type:o}=e,s=e.negate?"not.":"";if(o==="column")if(e.operator==="like"||e.operator==="ilike"){let a=t?e.value.replaceAll("%","*"):e.value;return[e.column,`${s}${e.operator}.${a}`]}else if(e.operator==="in"){let a=e.value.map(i=>i.toString().includes(",")?`"${i}"`:i).join(",");return[e.column,`${s}${e.operator}.(${a})`]}else if(e.operator==="fts"||e.operator==="plfts"||e.operator==="phfts"||e.operator==="wfts"){let a=e.config?`(${e.config})`:"";return[e.column,`${s}${e.operator}${a}.${e.value}`]}else return[e.column,`${s}${e.operator}.${e.value}`];else{if(o==="logical")return[`${s}${e.operator}`,`(${e.values.map(a=>q(a,t,r)).join(r)})`];throw new Error(`Unknown filter type '${o}'`)}}function q(e,t=!0,r=","){let[o,s]=V(e,t,r),{type:a}=e;if(a==="column")return`${o}.${s}`;if(a==="logical")return`${o}${s}`;throw new Error(`Unknown filter type '${a}'`)}var re=["*","(",")",",",":","!",">","-","[","]"];function ne(e,t=re){return oe(e.toString(),t)}function Y(e,t=re){return oe(encodeURIComponent(e),t)}function oe(e,t){let r=e;for(let o of t){let s=o.charCodeAt(0).toString(16).toUpperCase();r=r.replaceAll(`%${s}`,o)}return r}async function Do(e){switch(e.type){case"select":return ze(e);default:throw new x(`Unsupported statement type '${e.type}'`,"http")}}async function ze(e){let{from:t,targets:r,filter:o,sorts:s,limit:a}=e,i=new URLSearchParams;if(r.length>0){let[u]=r;(u.type!=="column-target"||u.column!=="*"||r.length!==1)&&i.set("select",$(r))}if(o&&ae(i,o),s){let u=[];for(let m of s){let f=m.column;m.direction&&(f+=`.${m.direction}`),m.nulls&&(f+=`.nulls${m.nulls}`),u.push(f)}u.length>0&&i.set("order",u.join(","))}a&&(a.count!==void 0&&i.set("limit",a.count.toString()),a.offset!==void 0&&i.set("offset",a.offset.toString()));let l=`/${t}`;return{method:"GET",path:l,params:i,get fullPath(){return Array.from(i).length>0?`${l}?${ne(i)}`:l}}}function ae(e,t){let{type:r}=t;if(r==="logical"&&t.operator==="and"&&!t.negate)for(let o of t.values)ae(e,o);else{let[o,s]=V(t);e.append(o,s)}}function Vo(e,t){let{method:r,fullPath:o}=t,s=new URL(e);return F`
    ${r} ${s.pathname}${o} HTTP/1.1
    Host: ${s.host}
  `}function Yo(e,t){let{method:r,path:o,params:s}=t,a=[],i=new URL(e),l=(i.origin+i.pathname).replace(/\/+$/,""),u=s.size>0?"-G ":"";if(r==="GET"){a.push(`curl ${u}${l}${o}`);for(let[m,f]of s)a.push(`  -d "${Y(m)}=${Y(f)}"`)}return a.join(` \\
`)}import*as Ze from"prettier/plugins/babel";import*as et from"prettier/plugins/estree";import*as ie from"prettier/standalone";async function Qo(e){switch(e.type){case"select":return tt(e);default:throw new x(`Unsupported statement type '${e.type}'`,"supabase-js")}}async function tt(e){let{from:t,targets:r,filter:o,sorts:s,limit:a}=e,i=["const { data, error } = await supabase",`.from('${t}')`];if(r.length>0){let[u]=r;u.type==="column-target"&&u.column==="*"&&r.length===1?i.push(".select()"):r.length>1?i.push(`.select(
    \`
${$(r,{initialIndent:4,indent:2})}
    \`
 )`):i.push(`.select(${JSON.stringify($(r))})`)}if(o&&se(i,o),s)for(let u of s)if(!u.direction&&!u.nulls)i.push(`.order(${JSON.stringify(u.column)})`);else{let m={ascending:u.direction?u.direction==="asc":void 0,nullsFirst:u.nulls?u.nulls==="first":void 0};i.push(`.order(${JSON.stringify(u.column)}, ${JSON.stringify(m)})`)}if(a)if(a.count!==void 0&&a.offset===void 0)i.push(`.limit(${a.count})`);else{if(a.count===void 0&&a.offset!==void 0)throw new x("supabase-js doesn't support an offset without a limit","supabase-js");a.count!==void 0&&a.offset!==void 0&&i.push(`.range(${a.offset}, ${a.offset+a.count})`)}return{code:(await ie.format(i.join(`
`),{parser:"babel",plugins:[Ze,et],printWidth:40,semi:!1,singleQuote:!0,trailingComma:"all"})).trim()}}function se(e,t){let{type:r}=t;if(t.negate){if(t.type==="column")if(t.operator==="fts"||t.operator==="plfts"||t.operator==="phfts"||t.operator==="wfts"){let o=t.config?`(${t.config})`:"";e.push(`.not(${JSON.stringify(t.column)}, ${JSON.stringify(`${t.operator}${o}`)}, ${JSON.stringify(t.value)})`)}else e.push(`.not(${JSON.stringify(t.column)}, ${JSON.stringify(t.operator)}, ${JSON.stringify(t.value)})`);else t.type==="logical"&&e.push(`.or(${JSON.stringify(q(t,!1,", "))})`);return}if(r==="column")if(t.operator==="fts"||t.operator==="plfts"||t.operator==="phfts"||t.operator==="wfts"){let o=t.operator!=="fts"||t.config!==void 0?`, ${JSON.stringify({type:rt(t.operator),config:t.config})}`:"";e.push(`.textSearch(${JSON.stringify(t.column)}, ${JSON.stringify(t.value)}${o})`)}else e.push(`.${t.operator}(${JSON.stringify(t.column)}, ${JSON.stringify(t.value)})`);else if(r==="logical")if(t.operator==="and")for(let o of t.values)se(e,o);else t.operator==="or"&&e.push(`.or(${JSON.stringify(t.values.map(o=>q(o,!1,", ")).join(", "))})`);else throw new x(`Unknown filter type '${r}'`,"supabase-js")}function rt(e){switch(e){case"plfts":return"plain";case"phfts":return"phrase";case"wfts":return"websearch";default:return}}export{O as ParsingError,x as RenderError,R as UnimplementedError,n as UnsupportedError,j as everyTarget,X as flattenTargets,Yo as formatCurl,Vo as formatHttp,M as getParsingErrorHint,bt as processSql,Do as renderHttp,Qo as renderSupabaseJs,ue as sentenceCase,G as someFilter,C as someTarget,B as supportedAggregateFunctions};
//# sourceMappingURL=index.js.map