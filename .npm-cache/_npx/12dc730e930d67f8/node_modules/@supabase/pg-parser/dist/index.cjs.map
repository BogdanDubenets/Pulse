{"version":3,"sources":["/home/runner/work/pg-parser/pg-parser/packages/pg-parser/dist/index.cjs","../src/errors.ts","../src/constants.ts","../src/util.ts","../src/pg-parser.ts"],"names":[],"mappings":"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","file":"/home/runner/work/pg-parser/pg-parser/packages/pg-parser/dist/index.cjs","sourcesContent":[null,"export type ParseErrorType = 'syntax' | 'semantic' | 'unknown';\n\nexport type ParseErrorDetails = {\n  type: ParseErrorType;\n  position: number;\n};\n\nexport class ParseError extends Error {\n  override readonly name = 'ParseError';\n\n  /**\n   * The type of parse error. Possible values are:\n   *\n   * - `syntax`: A lexical or syntactic error, such as mismatched parentheses,\n   *   unterminated quotes, invalid tokens, or incorrect SQL statement structure.\n   *   Most SQL errors will fall into this category.\n   *\n   * - `semantic`: These are rare, but can occur during specific validations like\n   *   numeric range checking (e.g., column numbers must be between 1 and 32767\n   *   in ALTER INDEX statements).\n   *\n   * - `unknown`: An unknown error type, typically representing an internal parser error.\n   *\n   * Note: The vast majority of semantic validation (type checking, schema validation,\n   * constraint validation, etc.) happens after parsing and is not represented in these error types.\n   */\n  type: ParseErrorType;\n\n  /**\n   * The position of the error in the SQL string.\n   * This is a zero-based index, so the first character is at position 0.\n   * Points to the character where the error was detected.\n   */\n  position: number;\n\n  constructor(message: string, { type, position }: ParseErrorDetails) {\n    super(message);\n    this.type = type;\n    this.position = position;\n  }\n}\n\n/**\n * An error that occurred while deparsing an AST back to SQL.\n *\n * Unlike `ParseError`, deparse errors don't have a position or type\n * since they operate on an AST rather than a SQL string.\n */\nexport class DeparseError extends Error {\n  override readonly name = 'DeparseError';\n}\n\nexport type ScanErrorType = 'syntax' | 'unknown';\n\nexport type ScanErrorDetails = {\n  type: ScanErrorType;\n  position: number;\n};\n\n/**\n * An error that occurred while scanning/lexing a SQL string.\n *\n * Scan errors are always lexical in nature (e.g. unterminated string\n * literals, invalid escape sequences).\n */\nexport class ScanError extends Error {\n  override readonly name = 'ScanError';\n\n  /**\n   * The type of scan error. Will be `syntax` for lexical errors\n   * from the scanner, or `unknown` for unexpected internal errors.\n   */\n  type: ScanErrorType;\n\n  /**\n   * The position of the error in the SQL string.\n   * This is a zero-based index, so the first character is at position 0.\n   */\n  position: number;\n\n  constructor(message: string, { type, position }: ScanErrorDetails) {\n    super(message);\n    this.type = type;\n    this.position = position;\n  }\n}\n\n/**\n * Get the type of parse error based on the internal file name\n * returned from libpg_query.\n */\nexport function getParseErrorType(fileName: string): ParseErrorType {\n  switch (fileName) {\n    case 'scan.l':\n      return 'syntax';\n    case 'gram.y':\n      return 'semantic';\n    default:\n      return 'unknown';\n  }\n}\n","export const SUPPORTED_VERSIONS = [15, 16, 17] as const;\n","import { SUPPORTED_VERSIONS } from './constants.js';\nimport type {\n  Node,\n  ParseResult,\n  SupportedVersion,\n  WrappedDeparseResult,\n  WrappedParseResult,\n  WrappedScanResult,\n} from './types/index.js';\n\n/**\n * Extracts keys from a union type.\n */\ntype ExtractKeys<T> = T extends T ? keyof T : never;\n\n/**\n * Unwraps a Node to get its underlying value based on\n * the specified type of the node.\n */\nexport type NodeValue<T extends Node, U extends ExtractKeys<T>> =\n  T extends Record<U, infer V> ? V : never;\n\n/**\n * Unwraps a Node into its type and value.\n */\nexport type UnwrappedNode<T extends Node> =\n  T extends Record<infer K, infer V> ? { type: K; node: V } : never;\n\n/**\n * Unwraps a `WrappedParseResult` by throwing an error if the result\n * contains an `error`, or otherwise returning the parsed `tree`.\n *\n * Supports both synchronous and asynchronous results.\n */\nexport async function unwrapParseResult<Version extends SupportedVersion>(\n  result: WrappedParseResult<Version> | Promise<WrappedParseResult<Version>>\n) {\n  const resolved = await result;\n  if (resolved.error) {\n    throw resolved.error;\n  }\n  return resolved.tree;\n}\n\n/**\n * Unwraps a `WrappedDeparseResult` by throwing an error if the result\n * contains an `error`, or otherwise returning the deparsed SQL string.\n *\n * Supports both synchronous and asynchronous results.\n */\nexport async function unwrapDeparseResult(\n  result: WrappedDeparseResult | Promise<WrappedDeparseResult>\n) {\n  const resolved = await result;\n  if (resolved.error) {\n    throw resolved.error;\n  }\n  return resolved.sql;\n}\n\n/**\n * Unwraps a `WrappedScanResult` by throwing an error if the result\n * contains an `error`, or otherwise returning the scanned tokens.\n *\n * Supports both synchronous and asynchronous results.\n */\nexport async function unwrapScanResult(\n  result: WrappedScanResult | Promise<WrappedScanResult>\n) {\n  const resolved = await result;\n  if (resolved.error) {\n    throw resolved.error;\n  }\n  return resolved.tokens;\n}\n\n/**\n * Gets a list of supported Postgres versions.\n */\nexport function getSupportedVersions() {\n  return SUPPORTED_VERSIONS;\n}\n\n/**\n * Type guard to check if the major Postgres version is supported.\n */\nexport function isSupportedVersion(\n  version: number\n): version is SupportedVersion {\n  return SUPPORTED_VERSIONS.includes(version as SupportedVersion);\n}\n\n/**\n * Type guard to check if the `ParseResult` is of a specific version.\n */\nexport function isParseResultVersion<Version extends SupportedVersion>(\n  result: ParseResult,\n  version: Version\n): result is ParseResult<Version> {\n  if (!result.version) {\n    return false;\n  }\n\n  // `result.version` looks like 170004\n  const versionString = result.version.toString();\n\n  try {\n    // Strip away the last 4 digits\n    const majorVersion = parseInt(versionString.slice(0, -4), 10);\n\n    // Compare the major version with the provided version\n    return majorVersion === version;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Asserts that a value is defined.\n *\n * Useful for type narrowing.\n */\nexport function assertDefined<T>(\n  value: T | undefined,\n  errorMessage: string\n): asserts value is T {\n  if (value === undefined) {\n    throw new Error(errorMessage);\n  }\n}\n\n/**\n * Unwraps a `Node` to get its type and underlying value.\n *\n * Unwrapping makes it easier to work with nodes\n * by allowing you to narrow them based on their type.\n *\n * @example\n * const tree = await unwrapParseResult(parser.parse('SELECT 1'));\n * const firstStmt = tree.stmts.[0].stmt;\n * const { type, node } = unwrapNode(firstStmt);\n *\n * switch (type) {\n *  case 'SelectStmt':\n *    // Now `node` is narrowed to `SelectStmt`\n *    break;\n * }\n */\nexport function unwrapNode<T extends Node>(wrappedNode: T) {\n  const keys = Object.keys(wrappedNode) as ExtractKeys<T>[];\n\n  if (keys.length === 0) {\n    throw new Error('node has no keys, expected a single key');\n  }\n\n  if (keys.length > 1) {\n    throw new Error(\n      `node has multiple keys, expected a single key: ${keys.join(', ')}`\n    );\n  }\n\n  const [type] = keys;\n\n  if (!type) {\n    throw new Error('node has no keys, expected a single key');\n  }\n\n  const node = wrappedNode[type];\n\n  return { type, node } as UnwrappedNode<T>;\n}\n\n/**\n * Asserts that a `Node` is a specific type and\n * unwraps its underlying value.\n *\n * @returns The unwrapped `Node` value.\n * @throws If `node` is not of type `type`.\n */\nexport function assertAndUnwrapNode<T extends Node, U extends ExtractKeys<T>>(\n  wrappedNode: T,\n  expectedType: U,\n  errorMessage?: string\n): NodeValue<T, U> {\n  const { type, node } = unwrapNode(wrappedNode);\n\n  if (type !== expectedType) {\n    throw new Error(\n      errorMessage ?? `expected node of type ${expectedType}, got ${type}`\n    );\n  }\n\n  return node as NodeValue<T, U>;\n}\n","import {\n  DeparseError,\n  getParseErrorType,\n  ParseError,\n  type ParseErrorType,\n  ScanError,\n  type ScanErrorType,\n} from './errors.js';\nimport type {\n  KeywordKind,\n  MainModule,\n  ParseResult,\n  PgParserModule,\n  ScanToken,\n  SupportedVersion,\n  WrappedDeparseResult,\n  WrappedParseResult,\n  WrappedScanResult,\n} from './types/index.js';\nimport { isSupportedVersion } from './util.js';\n\ntype Pointer = number;\n\nconst textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\n\nconst KEYWORD_KINDS: KeywordKind[] = [\n  'none',\n  'unreserved',\n  'col_name',\n  'type_func_name',\n  'reserved',\n];\n\n/**\n * Reads a null-terminated UTF-8 string from the WASM heap.\n */\nfunction readString(heap: Int8Array, ptr: number): string {\n  let end = ptr;\n  while (heap[end] !== 0) end++;\n  return textDecoder.decode(new Uint8Array(heap.buffer, ptr, end - ptr));\n}\n\nexport type PgParserOptions<Version extends SupportedVersion> = {\n  version?: Version | number;\n};\n\nexport class PgParser<Version extends SupportedVersion = 17> {\n  readonly ready: Promise<void>;\n  readonly version: Version;\n\n  #module: Promise<MainModule<Version>>;\n\n  /**\n   * Creates a new PgParser instance with the given options.\n   */\n  constructor({ version = 17 }: PgParserOptions<Version> = {}) {\n    if (!isSupportedVersion(version)) {\n      throw new Error(`unsupported version: ${version}`);\n    }\n\n    this.#module = this.#init(version);\n    this.ready = this.#module.then();\n    this.version = version as Version;\n  }\n\n  /**\n   * Returns the current WASM heap size in bytes.\n   * Useful for detecting memory leaks in tests.\n   */\n  async getHeapSize(): Promise<number> {\n    const module = await this.#module;\n    return module.HEAP8.length;\n  }\n\n  /**\n   * Initializes the WASM module.\n   */\n  async #init(version: SupportedVersion) {\n    const createModule = await this.#loadFactory(version);\n\n    // In Node.js (including SSR), tell Emscripten to resolve the WASM file\n    // using its script directory instead of `new URL(file, import.meta.url)`.\n    // Bundlers like webpack/turbopack rewrite that URL pattern into an asset\n    // path (e.g. /_next/static/media/...) that isn't valid on the filesystem.\n    // The script directory is correctly derived from import.meta.url by the\n    // Emscripten glue code and points to the actual .wasm file location.\n    const isNode =\n      typeof process !== 'undefined' && !!process.versions?.node;\n\n    return await createModule(\n      isNode\n        ? {\n            locateFile: (path: string, scriptDirectory: string) =>\n              scriptDirectory + path,\n          }\n        : undefined\n    );\n  }\n\n  /**\n   * Loads the WASM module factory for the given version.\n   *\n   * Note we intentionally don't use template strings on a single import\n   * statement to avoid bundling issues that occur during static analysis.\n   */\n  async #loadFactory(version: SupportedVersion) {\n    switch (version) {\n      case 15:\n        return await import('../wasm/15/pg-parser.js').then<\n          PgParserModule<Version>\n        >((module) => module.default);\n      case 16:\n        return await import('../wasm/16/pg-parser.js').then<\n          PgParserModule<Version>\n        >((module) => module.default);\n      case 17:\n        return await import('../wasm/17/pg-parser.js').then<\n          PgParserModule<Version>\n        >((module) => module.default);\n      default:\n        throw new Error(`unsupported version: ${version}`);\n    }\n  }\n\n  /**\n   * Parses the given SQL string to a Postgres AST.\n   */\n  async parse(sql: string) {\n    const module = await this.#module;\n\n    const sqlBytes = textEncoder.encode(sql);\n    const sqlPtr = module._malloc(sqlBytes.length + 1); // +1 for null terminator\n    module.HEAP8.set(sqlBytes, sqlPtr);\n    module.HEAP8[sqlPtr + sqlBytes.length] = 0; // null terminator\n\n    const resultPtr = module._parse_sql(sqlPtr);\n    module._free(sqlPtr);\n\n    try {\n      return await this.#parsePgQueryParseResult(resultPtr);\n    } finally {\n      module._free_parse_result(resultPtr);\n    }\n  }\n\n  /**\n   * Parses a PgQueryParseResult struct from a pointer\n   */\n  async #parsePgQueryParseResult(\n    resultPtr: number\n  ): Promise<WrappedParseResult<Version>> {\n    const module = await this.#module;\n\n    if (!resultPtr) {\n      throw new Error('result pointer is null (protobuf to json failed)');\n    }\n\n    const parseTreePtr = module.getValue(resultPtr, 'i32');\n    const stderrBufferPtr = module.getValue(resultPtr + 4, 'i32');\n    const errorPtr = module.getValue(resultPtr + 8, 'i32');\n\n    const tree = parseTreePtr\n      ? JSON.parse(readString(module.HEAP8, parseTreePtr))\n      : undefined;\n\n    // TODO: add debug mode + print this to stdout/stderr\n    const stderrBuffer = stderrBufferPtr\n      ? readString(module.HEAP8, stderrBufferPtr)\n      : undefined;\n\n    const error = errorPtr\n      ? await this.#parsePgQueryError(errorPtr)\n      : undefined;\n\n    if (error) {\n      return {\n        tree: undefined,\n        error,\n      };\n    }\n\n    if (!parseTreePtr) {\n      throw new Error('parse tree is undefined');\n    }\n\n    if (!tree) {\n      throw new Error('both parse tree and error are undefined');\n    }\n\n    return {\n      tree,\n      error: undefined,\n    };\n  }\n\n  async deparse(\n    parseResult: ParseResult<Version>\n  ): Promise<WrappedDeparseResult> {\n    const module = await this.#module;\n\n    const json = JSON.stringify(parseResult);\n\n    const jsonBytes = textEncoder.encode(json);\n    const jsonPtr = module._malloc(jsonBytes.length + 1); // +1 for null terminator\n    module.HEAP8.set(jsonBytes, jsonPtr);\n    module.HEAP8[jsonPtr + jsonBytes.length] = 0; // null terminator\n\n    const deparseResultPtr: Pointer = module._deparse_sql(jsonPtr);\n    module._free(jsonPtr);\n\n    if (!deparseResultPtr) {\n      throw new Error('deparse failed: null result pointer');\n    }\n\n    try {\n      // Parse struct PgQueryDeparseResult from the pointer\n      const queryPtr = module.getValue(deparseResultPtr, 'i32');\n      const errorPtr = module.getValue(deparseResultPtr + 4, 'i32');\n      const error = errorPtr\n        ? await this.#parseDeparseError(errorPtr)\n        : undefined;\n\n      if (error) {\n        return {\n          sql: undefined,\n          error,\n        };\n      }\n\n      const sql = queryPtr ? readString(module.HEAP8, queryPtr) : undefined;\n\n      if (!sql) {\n        throw new Error('query is undefined');\n      }\n\n      return {\n        sql,\n        error: undefined,\n      };\n    } finally {\n      module._free_deparse_result(deparseResultPtr);\n    }\n  }\n\n  /**\n   * Reads the common fields from a PgQueryError struct pointer.\n   *\n   * The struct layout (WASM32) is:\n   * ```c\n   * typedef struct {\n   *   char *message;     // offset 0\n   *   char *funcname;    // offset 4\n   *   char *filename;    // offset 8\n   *   int lineno;        // offset 12\n   *   int cursorpos;     // offset 16\n   *   char *context;     // offset 20\n   * } PgQueryError;\n   * ```\n   */\n  async #readPgQueryError(errorPtr: number) {\n    const module = await this.#module;\n\n    const messagePtr = module.getValue(errorPtr, 'i32');\n    const fileNamePtr = module.getValue(errorPtr + 8, 'i32');\n    const cursorpos = module.getValue(errorPtr + 16, 'i32');\n\n    const message = messagePtr\n      ? readString(module.HEAP8, messagePtr)\n      : 'unknown error';\n    const fileName = fileNamePtr\n      ? readString(module.HEAP8, fileNamePtr)\n      : undefined;\n    const position = cursorpos > 0 ? cursorpos - 1 : 0; // Convert 1-based to 0-based\n\n    return { message, fileName, position };\n  }\n\n  async #parsePgQueryError(errorPtr: number) {\n    const { message, fileName, position } =\n      await this.#readPgQueryError(errorPtr);\n    const type: ParseErrorType = fileName\n      ? getParseErrorType(fileName)\n      : 'unknown';\n    return new ParseError(message, { type, position });\n  }\n\n  /**\n   * Reads a PgQueryError struct from a pointer and returns a DeparseError.\n   * Only reads the message field since deparse errors don't have\n   * meaningful position or type information.\n   */\n  async #parseDeparseError(errorPtr: number) {\n    const { message } = await this.#readPgQueryError(errorPtr);\n    return new DeparseError(message);\n  }\n\n  /**\n   * Scans (lexes) the given SQL string into an array of tokens.\n   *\n   * Each token includes its kind (raw PG token name), the original text,\n   * byte offsets, and keyword classification.\n   */\n  async scan(sql: string): Promise<WrappedScanResult> {\n    const module = await this.#module;\n\n    const sqlBytes = textEncoder.encode(sql);\n    const sqlPtr = module._malloc(sqlBytes.length + 1);\n    module.HEAP8.set(sqlBytes, sqlPtr);\n    module.HEAP8[sqlPtr + sqlBytes.length] = 0;\n\n    const resultPtr = module._scan_sql(sqlPtr);\n    module._free(sqlPtr);\n\n    if (!resultPtr) {\n      throw new Error('scan failed: null result pointer');\n    }\n\n    try {\n      // PgScanResult struct: n_tokens(4) + tokens_ptr(4) + error_ptr(4)\n      const nTokens = module.getValue(resultPtr, 'i32');\n      const tokensPtr = module.getValue(resultPtr + 4, 'i32');\n      const errorPtr = module.getValue(resultPtr + 8, 'i32');\n\n      if (errorPtr) {\n        const error = await this.#parseScanError(errorPtr);\n        return { tokens: undefined, error };\n      }\n\n      const tokens: ScanToken[] = [];\n      for (let i = 0; i < nTokens; i++) {\n        // ScanTokenData: start(4) + end(4) + name_ptr(4) + keyword_kind(4) = 16 bytes\n        const base = tokensPtr + i * 16;\n        const start = module.getValue(base, 'i32');\n        const end = module.getValue(base + 4, 'i32');\n        const namePtr = module.getValue(base + 8, 'i32');\n        const kwKind = module.getValue(base + 12, 'i32');\n\n        tokens.push({\n          kind: readString(module.HEAP8, namePtr),\n          text: textDecoder.decode(sqlBytes.slice(start, end)),\n          start,\n          end,\n          keywordKind: KEYWORD_KINDS[kwKind] ?? 'none',\n        });\n      }\n\n      return { tokens, error: undefined };\n    } finally {\n      module._free_scan_result(resultPtr);\n    }\n  }\n\n  async #parseScanError(errorPtr: number) {\n    const { message, fileName, position } =\n      await this.#readPgQueryError(errorPtr);\n    const type: ScanErrorType = fileName\n      ? (getParseErrorType(fileName) === 'syntax' ? 'syntax' : 'unknown')\n      : 'unknown';\n    return new ScanError(message, { type, position });\n  }\n}\n"]}