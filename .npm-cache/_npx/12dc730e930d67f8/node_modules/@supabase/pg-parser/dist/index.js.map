{"version":3,"sources":["../src/errors.ts","../src/constants.ts","../src/util.ts","../src/pg-parser.ts"],"sourcesContent":["export type ParseErrorType = 'syntax' | 'semantic' | 'unknown';\n\nexport type ParseErrorDetails = {\n  type: ParseErrorType;\n  position: number;\n};\n\nexport class ParseError extends Error {\n  override readonly name = 'ParseError';\n\n  /**\n   * The type of parse error. Possible values are:\n   *\n   * - `syntax`: A lexical or syntactic error, such as mismatched parentheses,\n   *   unterminated quotes, invalid tokens, or incorrect SQL statement structure.\n   *   Most SQL errors will fall into this category.\n   *\n   * - `semantic`: These are rare, but can occur during specific validations like\n   *   numeric range checking (e.g., column numbers must be between 1 and 32767\n   *   in ALTER INDEX statements).\n   *\n   * - `unknown`: An unknown error type, typically representing an internal parser error.\n   *\n   * Note: The vast majority of semantic validation (type checking, schema validation,\n   * constraint validation, etc.) happens after parsing and is not represented in these error types.\n   */\n  type: ParseErrorType;\n\n  /**\n   * The position of the error in the SQL string.\n   * This is a zero-based index, so the first character is at position 0.\n   * Points to the character where the error was detected.\n   */\n  position: number;\n\n  constructor(message: string, { type, position }: ParseErrorDetails) {\n    super(message);\n    this.type = type;\n    this.position = position;\n  }\n}\n\n/**\n * An error that occurred while deparsing an AST back to SQL.\n *\n * Unlike `ParseError`, deparse errors don't have a position or type\n * since they operate on an AST rather than a SQL string.\n */\nexport class DeparseError extends Error {\n  override readonly name = 'DeparseError';\n}\n\nexport type ScanErrorType = 'syntax' | 'unknown';\n\nexport type ScanErrorDetails = {\n  type: ScanErrorType;\n  position: number;\n};\n\n/**\n * An error that occurred while scanning/lexing a SQL string.\n *\n * Scan errors are always lexical in nature (e.g. unterminated string\n * literals, invalid escape sequences).\n */\nexport class ScanError extends Error {\n  override readonly name = 'ScanError';\n\n  /**\n   * The type of scan error. Will be `syntax` for lexical errors\n   * from the scanner, or `unknown` for unexpected internal errors.\n   */\n  type: ScanErrorType;\n\n  /**\n   * The position of the error in the SQL string.\n   * This is a zero-based index, so the first character is at position 0.\n   */\n  position: number;\n\n  constructor(message: string, { type, position }: ScanErrorDetails) {\n    super(message);\n    this.type = type;\n    this.position = position;\n  }\n}\n\n/**\n * Get the type of parse error based on the internal file name\n * returned from libpg_query.\n */\nexport function getParseErrorType(fileName: string): ParseErrorType {\n  switch (fileName) {\n    case 'scan.l':\n      return 'syntax';\n    case 'gram.y':\n      return 'semantic';\n    default:\n      return 'unknown';\n  }\n}\n","export const SUPPORTED_VERSIONS = [15, 16, 17] as const;\n","import { SUPPORTED_VERSIONS } from './constants.js';\nimport type {\n  Node,\n  ParseResult,\n  SupportedVersion,\n  WrappedDeparseResult,\n  WrappedParseResult,\n  WrappedScanResult,\n} from './types/index.js';\n\n/**\n * Extracts keys from a union type.\n */\ntype ExtractKeys<T> = T extends T ? keyof T : never;\n\n/**\n * Unwraps a Node to get its underlying value based on\n * the specified type of the node.\n */\nexport type NodeValue<T extends Node, U extends ExtractKeys<T>> =\n  T extends Record<U, infer V> ? V : never;\n\n/**\n * Unwraps a Node into its type and value.\n */\nexport type UnwrappedNode<T extends Node> =\n  T extends Record<infer K, infer V> ? { type: K; node: V } : never;\n\n/**\n * Unwraps a `WrappedParseResult` by throwing an error if the result\n * contains an `error`, or otherwise returning the parsed `tree`.\n *\n * Supports both synchronous and asynchronous results.\n */\nexport async function unwrapParseResult<Version extends SupportedVersion>(\n  result: WrappedParseResult<Version> | Promise<WrappedParseResult<Version>>\n) {\n  const resolved = await result;\n  if (resolved.error) {\n    throw resolved.error;\n  }\n  return resolved.tree;\n}\n\n/**\n * Unwraps a `WrappedDeparseResult` by throwing an error if the result\n * contains an `error`, or otherwise returning the deparsed SQL string.\n *\n * Supports both synchronous and asynchronous results.\n */\nexport async function unwrapDeparseResult(\n  result: WrappedDeparseResult | Promise<WrappedDeparseResult>\n) {\n  const resolved = await result;\n  if (resolved.error) {\n    throw resolved.error;\n  }\n  return resolved.sql;\n}\n\n/**\n * Unwraps a `WrappedScanResult` by throwing an error if the result\n * contains an `error`, or otherwise returning the scanned tokens.\n *\n * Supports both synchronous and asynchronous results.\n */\nexport async function unwrapScanResult(\n  result: WrappedScanResult | Promise<WrappedScanResult>\n) {\n  const resolved = await result;\n  if (resolved.error) {\n    throw resolved.error;\n  }\n  return resolved.tokens;\n}\n\n/**\n * Gets a list of supported Postgres versions.\n */\nexport function getSupportedVersions() {\n  return SUPPORTED_VERSIONS;\n}\n\n/**\n * Type guard to check if the major Postgres version is supported.\n */\nexport function isSupportedVersion(\n  version: number\n): version is SupportedVersion {\n  return SUPPORTED_VERSIONS.includes(version as SupportedVersion);\n}\n\n/**\n * Type guard to check if the `ParseResult` is of a specific version.\n */\nexport function isParseResultVersion<Version extends SupportedVersion>(\n  result: ParseResult,\n  version: Version\n): result is ParseResult<Version> {\n  if (!result.version) {\n    return false;\n  }\n\n  // `result.version` looks like 170004\n  const versionString = result.version.toString();\n\n  try {\n    // Strip away the last 4 digits\n    const majorVersion = parseInt(versionString.slice(0, -4), 10);\n\n    // Compare the major version with the provided version\n    return majorVersion === version;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Asserts that a value is defined.\n *\n * Useful for type narrowing.\n */\nexport function assertDefined<T>(\n  value: T | undefined,\n  errorMessage: string\n): asserts value is T {\n  if (value === undefined) {\n    throw new Error(errorMessage);\n  }\n}\n\n/**\n * Unwraps a `Node` to get its type and underlying value.\n *\n * Unwrapping makes it easier to work with nodes\n * by allowing you to narrow them based on their type.\n *\n * @example\n * const tree = await unwrapParseResult(parser.parse('SELECT 1'));\n * const firstStmt = tree.stmts.[0].stmt;\n * const { type, node } = unwrapNode(firstStmt);\n *\n * switch (type) {\n *  case 'SelectStmt':\n *    // Now `node` is narrowed to `SelectStmt`\n *    break;\n * }\n */\nexport function unwrapNode<T extends Node>(wrappedNode: T) {\n  const keys = Object.keys(wrappedNode) as ExtractKeys<T>[];\n\n  if (keys.length === 0) {\n    throw new Error('node has no keys, expected a single key');\n  }\n\n  if (keys.length > 1) {\n    throw new Error(\n      `node has multiple keys, expected a single key: ${keys.join(', ')}`\n    );\n  }\n\n  const [type] = keys;\n\n  if (!type) {\n    throw new Error('node has no keys, expected a single key');\n  }\n\n  const node = wrappedNode[type];\n\n  return { type, node } as UnwrappedNode<T>;\n}\n\n/**\n * Asserts that a `Node` is a specific type and\n * unwraps its underlying value.\n *\n * @returns The unwrapped `Node` value.\n * @throws If `node` is not of type `type`.\n */\nexport function assertAndUnwrapNode<T extends Node, U extends ExtractKeys<T>>(\n  wrappedNode: T,\n  expectedType: U,\n  errorMessage?: string\n): NodeValue<T, U> {\n  const { type, node } = unwrapNode(wrappedNode);\n\n  if (type !== expectedType) {\n    throw new Error(\n      errorMessage ?? `expected node of type ${expectedType}, got ${type}`\n    );\n  }\n\n  return node as NodeValue<T, U>;\n}\n","import {\n  DeparseError,\n  getParseErrorType,\n  ParseError,\n  type ParseErrorType,\n  ScanError,\n  type ScanErrorType,\n} from './errors.js';\nimport type {\n  KeywordKind,\n  MainModule,\n  ParseResult,\n  PgParserModule,\n  ScanToken,\n  SupportedVersion,\n  WrappedDeparseResult,\n  WrappedParseResult,\n  WrappedScanResult,\n} from './types/index.js';\nimport { isSupportedVersion } from './util.js';\n\ntype Pointer = number;\n\nconst textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\n\nconst KEYWORD_KINDS: KeywordKind[] = [\n  'none',\n  'unreserved',\n  'col_name',\n  'type_func_name',\n  'reserved',\n];\n\n/**\n * Reads a null-terminated UTF-8 string from the WASM heap.\n */\nfunction readString(heap: Int8Array, ptr: number): string {\n  let end = ptr;\n  while (heap[end] !== 0) end++;\n  return textDecoder.decode(new Uint8Array(heap.buffer, ptr, end - ptr));\n}\n\nexport type PgParserOptions<Version extends SupportedVersion> = {\n  version?: Version | number;\n};\n\nexport class PgParser<Version extends SupportedVersion = 17> {\n  readonly ready: Promise<void>;\n  readonly version: Version;\n\n  #module: Promise<MainModule<Version>>;\n\n  /**\n   * Creates a new PgParser instance with the given options.\n   */\n  constructor({ version = 17 }: PgParserOptions<Version> = {}) {\n    if (!isSupportedVersion(version)) {\n      throw new Error(`unsupported version: ${version}`);\n    }\n\n    this.#module = this.#init(version);\n    this.ready = this.#module.then();\n    this.version = version as Version;\n  }\n\n  /**\n   * Returns the current WASM heap size in bytes.\n   * Useful for detecting memory leaks in tests.\n   */\n  async getHeapSize(): Promise<number> {\n    const module = await this.#module;\n    return module.HEAP8.length;\n  }\n\n  /**\n   * Initializes the WASM module.\n   */\n  async #init(version: SupportedVersion) {\n    const createModule = await this.#loadFactory(version);\n\n    // In Node.js (including SSR), tell Emscripten to resolve the WASM file\n    // using its script directory instead of `new URL(file, import.meta.url)`.\n    // Bundlers like webpack/turbopack rewrite that URL pattern into an asset\n    // path (e.g. /_next/static/media/...) that isn't valid on the filesystem.\n    // The script directory is correctly derived from import.meta.url by the\n    // Emscripten glue code and points to the actual .wasm file location.\n    const isNode =\n      typeof process !== 'undefined' && !!process.versions?.node;\n\n    return await createModule(\n      isNode\n        ? {\n            locateFile: (path: string, scriptDirectory: string) =>\n              scriptDirectory + path,\n          }\n        : undefined\n    );\n  }\n\n  /**\n   * Loads the WASM module factory for the given version.\n   *\n   * Note we intentionally don't use template strings on a single import\n   * statement to avoid bundling issues that occur during static analysis.\n   */\n  async #loadFactory(version: SupportedVersion) {\n    switch (version) {\n      case 15:\n        return await import('../wasm/15/pg-parser.js').then<\n          PgParserModule<Version>\n        >((module) => module.default);\n      case 16:\n        return await import('../wasm/16/pg-parser.js').then<\n          PgParserModule<Version>\n        >((module) => module.default);\n      case 17:\n        return await import('../wasm/17/pg-parser.js').then<\n          PgParserModule<Version>\n        >((module) => module.default);\n      default:\n        throw new Error(`unsupported version: ${version}`);\n    }\n  }\n\n  /**\n   * Parses the given SQL string to a Postgres AST.\n   */\n  async parse(sql: string) {\n    const module = await this.#module;\n\n    const sqlBytes = textEncoder.encode(sql);\n    const sqlPtr = module._malloc(sqlBytes.length + 1); // +1 for null terminator\n    module.HEAP8.set(sqlBytes, sqlPtr);\n    module.HEAP8[sqlPtr + sqlBytes.length] = 0; // null terminator\n\n    const resultPtr = module._parse_sql(sqlPtr);\n    module._free(sqlPtr);\n\n    try {\n      return await this.#parsePgQueryParseResult(resultPtr);\n    } finally {\n      module._free_parse_result(resultPtr);\n    }\n  }\n\n  /**\n   * Parses a PgQueryParseResult struct from a pointer\n   */\n  async #parsePgQueryParseResult(\n    resultPtr: number\n  ): Promise<WrappedParseResult<Version>> {\n    const module = await this.#module;\n\n    if (!resultPtr) {\n      throw new Error('result pointer is null (protobuf to json failed)');\n    }\n\n    const parseTreePtr = module.getValue(resultPtr, 'i32');\n    const stderrBufferPtr = module.getValue(resultPtr + 4, 'i32');\n    const errorPtr = module.getValue(resultPtr + 8, 'i32');\n\n    const tree = parseTreePtr\n      ? JSON.parse(readString(module.HEAP8, parseTreePtr))\n      : undefined;\n\n    // TODO: add debug mode + print this to stdout/stderr\n    const stderrBuffer = stderrBufferPtr\n      ? readString(module.HEAP8, stderrBufferPtr)\n      : undefined;\n\n    const error = errorPtr\n      ? await this.#parsePgQueryError(errorPtr)\n      : undefined;\n\n    if (error) {\n      return {\n        tree: undefined,\n        error,\n      };\n    }\n\n    if (!parseTreePtr) {\n      throw new Error('parse tree is undefined');\n    }\n\n    if (!tree) {\n      throw new Error('both parse tree and error are undefined');\n    }\n\n    return {\n      tree,\n      error: undefined,\n    };\n  }\n\n  async deparse(\n    parseResult: ParseResult<Version>\n  ): Promise<WrappedDeparseResult> {\n    const module = await this.#module;\n\n    const json = JSON.stringify(parseResult);\n\n    const jsonBytes = textEncoder.encode(json);\n    const jsonPtr = module._malloc(jsonBytes.length + 1); // +1 for null terminator\n    module.HEAP8.set(jsonBytes, jsonPtr);\n    module.HEAP8[jsonPtr + jsonBytes.length] = 0; // null terminator\n\n    const deparseResultPtr: Pointer = module._deparse_sql(jsonPtr);\n    module._free(jsonPtr);\n\n    if (!deparseResultPtr) {\n      throw new Error('deparse failed: null result pointer');\n    }\n\n    try {\n      // Parse struct PgQueryDeparseResult from the pointer\n      const queryPtr = module.getValue(deparseResultPtr, 'i32');\n      const errorPtr = module.getValue(deparseResultPtr + 4, 'i32');\n      const error = errorPtr\n        ? await this.#parseDeparseError(errorPtr)\n        : undefined;\n\n      if (error) {\n        return {\n          sql: undefined,\n          error,\n        };\n      }\n\n      const sql = queryPtr ? readString(module.HEAP8, queryPtr) : undefined;\n\n      if (!sql) {\n        throw new Error('query is undefined');\n      }\n\n      return {\n        sql,\n        error: undefined,\n      };\n    } finally {\n      module._free_deparse_result(deparseResultPtr);\n    }\n  }\n\n  /**\n   * Reads the common fields from a PgQueryError struct pointer.\n   *\n   * The struct layout (WASM32) is:\n   * ```c\n   * typedef struct {\n   *   char *message;     // offset 0\n   *   char *funcname;    // offset 4\n   *   char *filename;    // offset 8\n   *   int lineno;        // offset 12\n   *   int cursorpos;     // offset 16\n   *   char *context;     // offset 20\n   * } PgQueryError;\n   * ```\n   */\n  async #readPgQueryError(errorPtr: number) {\n    const module = await this.#module;\n\n    const messagePtr = module.getValue(errorPtr, 'i32');\n    const fileNamePtr = module.getValue(errorPtr + 8, 'i32');\n    const cursorpos = module.getValue(errorPtr + 16, 'i32');\n\n    const message = messagePtr\n      ? readString(module.HEAP8, messagePtr)\n      : 'unknown error';\n    const fileName = fileNamePtr\n      ? readString(module.HEAP8, fileNamePtr)\n      : undefined;\n    const position = cursorpos > 0 ? cursorpos - 1 : 0; // Convert 1-based to 0-based\n\n    return { message, fileName, position };\n  }\n\n  async #parsePgQueryError(errorPtr: number) {\n    const { message, fileName, position } =\n      await this.#readPgQueryError(errorPtr);\n    const type: ParseErrorType = fileName\n      ? getParseErrorType(fileName)\n      : 'unknown';\n    return new ParseError(message, { type, position });\n  }\n\n  /**\n   * Reads a PgQueryError struct from a pointer and returns a DeparseError.\n   * Only reads the message field since deparse errors don't have\n   * meaningful position or type information.\n   */\n  async #parseDeparseError(errorPtr: number) {\n    const { message } = await this.#readPgQueryError(errorPtr);\n    return new DeparseError(message);\n  }\n\n  /**\n   * Scans (lexes) the given SQL string into an array of tokens.\n   *\n   * Each token includes its kind (raw PG token name), the original text,\n   * byte offsets, and keyword classification.\n   */\n  async scan(sql: string): Promise<WrappedScanResult> {\n    const module = await this.#module;\n\n    const sqlBytes = textEncoder.encode(sql);\n    const sqlPtr = module._malloc(sqlBytes.length + 1);\n    module.HEAP8.set(sqlBytes, sqlPtr);\n    module.HEAP8[sqlPtr + sqlBytes.length] = 0;\n\n    const resultPtr = module._scan_sql(sqlPtr);\n    module._free(sqlPtr);\n\n    if (!resultPtr) {\n      throw new Error('scan failed: null result pointer');\n    }\n\n    try {\n      // PgScanResult struct: n_tokens(4) + tokens_ptr(4) + error_ptr(4)\n      const nTokens = module.getValue(resultPtr, 'i32');\n      const tokensPtr = module.getValue(resultPtr + 4, 'i32');\n      const errorPtr = module.getValue(resultPtr + 8, 'i32');\n\n      if (errorPtr) {\n        const error = await this.#parseScanError(errorPtr);\n        return { tokens: undefined, error };\n      }\n\n      const tokens: ScanToken[] = [];\n      for (let i = 0; i < nTokens; i++) {\n        // ScanTokenData: start(4) + end(4) + name_ptr(4) + keyword_kind(4) = 16 bytes\n        const base = tokensPtr + i * 16;\n        const start = module.getValue(base, 'i32');\n        const end = module.getValue(base + 4, 'i32');\n        const namePtr = module.getValue(base + 8, 'i32');\n        const kwKind = module.getValue(base + 12, 'i32');\n\n        tokens.push({\n          kind: readString(module.HEAP8, namePtr),\n          text: textDecoder.decode(sqlBytes.slice(start, end)),\n          start,\n          end,\n          keywordKind: KEYWORD_KINDS[kwKind] ?? 'none',\n        });\n      }\n\n      return { tokens, error: undefined };\n    } finally {\n      module._free_scan_result(resultPtr);\n    }\n  }\n\n  async #parseScanError(errorPtr: number) {\n    const { message, fileName, position } =\n      await this.#readPgQueryError(errorPtr);\n    const type: ScanErrorType = fileName\n      ? (getParseErrorType(fileName) === 'syntax' ? 'syntax' : 'unknown')\n      : 'unknown';\n    return new ScanError(message, { type, position });\n  }\n}\n"],"mappings":"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","names":[]}